[[{"l":"Readme"}],[{"l":"BlackTek Server"}],[{"l":"Getting Started"}],[{"l":"Compiling"}],[{"l":"Augment"}],[{"l":"Creature"}],[{"l":"Damage Modifier"}],[{"l":"Game"}],[{"l":"Item"}],[{"l":"Item Type"}],[{"l":"Monster"}],[{"l":"Player"}],[{"l":"Actions","p":["This is an apple \uD83C\uDF4E","This is an orange \uD83C\uDF4A","This is a banana \uD83C\uDF4C"]}],[{"l":"Chat Channels"}],[{"l":"Creature Events"}],[{"l":"Event CallBacks"}],[{"l":"Global Events"}],[{"l":"Move Events"}],[{"l":"NPC Interface"}],[{"l":"Spells"}],[{"l":"Talk Actions"}],[{"l":"Weapons"}],[{"l":"BlackTek Client"}],[{"l":"Getting Started"}],[{"l":"BlackTek Mapeditor"}],[{"l":"Getting Started"}],[{"l":"BlackTek Tools"}],[{"l":"Getting Started"}],[{"l":"Introduction"},{"l":"Fundamentals","p":["Introduction","Variables","Types","Operators","Control Structures","Loops","Scopes"]},{"l":"Concepts","p":["Closures","Iterators","Recursion","Metatables","Weak Tables","Memoization","Object-Oriented Programming"]},{"l":"Standard Libraries","p":["Basic","String","Table","Math","IO","Coroutine","OS (Operating System)","Package"]},{"l":"Auxiliary","p":["Optimizations","Benchmarking","Errors","Debugging"]}],[{"l":"Benchmarking","p":["With os.clock, you can compute (just about) the CPU time taken to execute a chunk of code.","By saving the time before starting the code and subtracting the before from the time after it executes, you get an approximate amount of seconds taken to execute that chunk of code.","Here's a benchmarking function to help with determining the performance of code:","unit: Unit of time to show the result in ('seconds', 'milliseconds', 'microseconds', or 'nanoseconds')","decPlaces: Number of decimal places to use when showing the elapsed time","n: Number of times to run the function","f: Function to run","...: Arguments passed to function f","Example of using it from the previous page:","Output of the above:"]}],[{"l":"Debugging","p":["When you're not sure why your code doesn't work or some statements aren't executing, a good method of making sure where you're getting to is by debugging with print statements.","This method will allow you to see how far your function or code gets before the error or something you're expecting doesn't happen, and lets you pinpoint what you need to fix.","Here for example, we swap the boolean's value to the opposite, and if a is true we're supposed to print 123. But the problem is, swap happens twice instead of returning the 1st time it's swapped (which is the \"example\" error in this case. Here, we can add prints to see what's going on to see why we can't print 123:","This current code will print:","We can see that we're obviously getting an expected value, after reassigning a to swap(a), which is the value we're supposed to use, but instead we swap it a 2nd time giving us back the original value (false->true->false). From here we know that the error is that we've swapped the boolean twice when it's supposed to be swapped once, so all we need to do is return a instead of return swap(a).","Now the code works as intended, and prints 123."]}],[{"l":"Errors"},{"l":"List of errors"},{"l":"Attempt to call a nil value","p":["Description: calling a function that doesn't exist","Example:"]},{"i":"unexpected-symbol-near-something","l":"Unexpected symbol near 'something'","p":["Description: an invalid character is placed next to a value/keyword/variable/function call"]},{"i":"attempt-to-index-global-variable-a-nil-value","l":"Attempt to index global 'variable' (a nil value)","p":["Description: indexing via [key] or .key for a variable that doesn't exist","Example:"]},{"l":"Attempt to perform arithmetic on a nil value","p":["Description: performing arithmetic (*, /, -, +, %, ^) on a nil value","Example:"]},{"i":"attempt-to-perform-arithmetic-on-field--a-nil-value","l":"Attempt to perform arithmetic on field '?' (a nil value)","p":["Description: performing arithmetic (*, /, -, +, %, ^) on a nil value","Example:"]},{"i":"attempt-to-compare-nil-with-type","l":"Attempt to compare nil with <TYPE>","p":["Description: using a comparison operator (<, >, ~=, ==, >=, <=) in which one side is a nil value","Example:"]},{"i":"malformed-number-near-number","l":"Malformed number near <NUMBER>","p":["Description: the number has an invalid character next to it","Example:"]},{"i":"unfinished-capture--malformed-pattern","l":"Unfinished capture | Malformed pattern","p":["Description: the pattern is missing a closing ), or a closing ]","Example:"]},{"l":"Interpreting errors","p":["When you get an error, Lua provides a stack trace showing you where it originates from, where the error occurs, the function calls that led to the error, and the line number of where it occurred.","A general error will look like this:","Here's an example:","The code that resulted in this error is:","Here you can see the line number 5 after the file location, which tells us where the exact line with the code that resulted in the error. The stack traceback shows the functions that were called that led up to that.","First, function a is called at line 12, then function b is called at line 9 inside of a, then c is called at line 7 inside of function b, and finally at line 5, the error occurs inside of function c.","A note to add is that comments can offset the line number and make it appear as the error is in a line that doesn't exist or doesn't look like an error,"]}],[{"l":"Optimizations"},{"l":"String concatenation","p":["Lua's garbage collector will run when it detects if too much memory is in use by the program. When using the string concat (..) operator, the result is a completely new string, and the old one is garbage if you're reassigning (which results in the old string having no reference) x = x .. \\n, the garbage collector will eventually run and collect this string. When you're concatenating large strings together over and over again (like in a loop) that will add up quickly and force the garbage collector to run and will slow down code by a lot the larger those strings are.","This code will take much longer to run because the more and more lines concatenated to result, the larger result is, and the larger result is, the more memory is used and forces the garbage collector to run.","A solution to speed this process up is by putting all strings into a table and running table.concat on it:","This will be much faster than manually concatenating all strings (table.concat uses a C implementation rather than Lua)","Before getting into the rest of the optimizations, you really don't need to be using these unless you're really trying to get performance out of a hugely expensive program or function call."]},{"l":"Squeezing performance from table indexing","p":["When indexing a table to retrieve a value, it takes time. Although a small amount of time, it can result in a decent chunk of time if you're running a function which takes a long time to finish regardless of this optimization. Calling lib functions such as string.len, table.concat, etc. all take time since they're a part of libraries which are tables. This is a way to store those functions without having to retrieve them over and over again:","Now we the function retrieved and stored in stringLen rather than having to retrieve it over and over again from the string library. Calling stringLen in an expensive function will increase performance by a lot.","Between these two functions, f will perform faster than f_2 because both functions used are saved in a local variable rather than getting retrieved from _G, which saves time over a long period of time."]},{"l":"Adding values to tables","p":["Lua provides a default function to insert a value into a table (table.insert), but, using this function takes significantly longer if you're just trying to insert a value into the next index that isn't used. If you're just looking to insert a new value into the next available index, this will perform much faster:","Here we just calculate the next index by using the current size + 1 (#t + 1) and insert a value into that new index.","If you're using a loop to insert new values, keeping track of the index manually will be faster than using the length operator each iteration:","Since we keep track of the index manually and add 1 each iteration, the length operator doesn't need to be used every single time which would add up after a while."]}],[{"l":"Closures","p":["A closure is when you enclose a function inside of another, like so:","When you create a closure, all of the variables are accessible in its parent's scope. In this case, b has access to a's scope. This provides a way to access and manipulate variables inside a function after its parent returns. The variables that the closure can access are called upvalues. The variables x and var are both upvalues to function b in this case.","Take this example, a simple function to increment a value, which is inaccessible without the closure:","Here we define a function that returns an anonymous function (a function that has no name or identifier) which will increment the upvalue i and return the value back to us.","Each time we call counter, it generates a new counter for us, it can be called any amount of times and all the counters will have different values. Each time the returned function from counter is called (the function that increments), it will only change that counter, no others.","For the print, the counters must be incremented again so we can get the value, since each time our incrementers run they return the variable after incrementing it."]}],[{"l":"Iterators","p":["Iterators provide a way to traverse data. Iterators will usually use a closure to keep track of what data it's on and uses that to determine what to give next.","Take the iterator ipairs for example, it traverses a table in sequence. Its implementation can be written like this:","Using closures, you can define your own way to iterate through a set of data. You could iterate half of it forward and half of it backwards, iterate the entire thing in reverse, iterate every 2 values, etc.","Here's what a reverse ipairs would look like:"]}],[{"l":"Memoization","p":["Memoization is a programming technique to basically \"cache\" expensive procedures or operations in order to avoid evaluating their results again.","Take this function for example, to generate a character list starting from lowercase chars up to a certain character code:","Here once generateCharlist is called the first time, that string is generated and inserted into the mem table, the next time it runs with the exact same param as the first call, it will use the pre-generated value rather than having to spend the time generating it again.","Do not use that code as a good \"optimized\" example of that process (specifically lines 7-10), since I intended for it to perform poorly. More info about why this is awful to do can be found in the Optimizations page."]}],[{"l":"Metatables","p":["Metatables are the underlying implementation of objects in Lua, they define custom behaviors such as addition between 2 objects, subtraction, accessing the value, etc.","Each of those are called metamethods, and they all begin with __.","All metamethods (Lua 5.1)","By default whenever you have a string, it has a metatable attached to it as you can see here:","When attempting to index the string, it instead returns the string library table. Which is why if you run this code, you'll see the __index of the metatable print this out:","You can directly access these by indexing the string directly, instead of going through the string library:","The second print uses the : syntactic sugar, both are equivalent, but the second is preferred for shorter code. The left hand of the : will be inserted as the first argument to string.len, and will result in the equivalent code: string.len(s).","You can create your own tables and define metatables for them to do as you'd like, like so:","Here we define a custom metamethod for the tostring function for the table, which instead calls table.concat to concatenate all table values in sequence with a separator of , inbetween each value."]}],[{"l":"Object-Oriented Programming","p":["Object-Oriented Programming (shortened to OOP) is a programming paradigm to wrap up a set of variables and functions (called methods) inside of a single object. A common example of this is a \"Player\" in a game, each player has the same set of variable names but different values, such as health, name, etc. A class is the definition of the variables and methods which are used by objects created using that class.","Since Lua has no true OOP implementation such as classes, we can get quite close to OOP and still be able to create unique objects and play around with them. The way we wrap all variables and functions inside a \"class\" is by holding all of that data in a table. Here's an example of creating a Player class:","The output of the above example results in:","Here we use the __call metamethod to create a definition on what happens when you call the table like it's a function. Player is defined at the top as a table, {}, but with the __call metamethod, doing Player(name, health) is valid. Once the __call metamethod is invoked, we simply take the arguments passed to it and insert it into a table. After which, we just simply return the table after using setmetatable to define our object's __index, which is used whenever we try to access the player object's table. The __index will hold everything inside of the Player table, but out object only holds name and health. Using __index, if what we're trying to access doesn't exist in the player object such as doing playerOne.xyz, it uses the table defined in __index to look in as well, if xyz is a key inside of Player, then that is returned.","We can see that here, there are 3 methods defined inside the Player table, which are getName, getHealth, and print. When calling playerOne:print(), it searches the player object which only holds {name = 'John', health = 100}, since print is not a key in our player object, it will search the Player table for it, and since we did define a print method, that will be used.","Again, playerOne:print() is the equivalent to Player.print(playerOne), just shorter and using the : syntax sugar."]}],[{"l":"Recursion","p":["Recursion is a technique used to use an algorithm or function that calls itself repetitively until a certain condition is satisfied.","The go-to example for recursion is a factorial function:","Here it will calculate the factorial by returning each value multiplied by the result of fact(n - 1). It can be a bit confusing, since we know return breaks out and gives back a value to whatever called the function, but before a return can give back a value, it needs to be evaluated first. And until n reaches 0, it will keep trying to evaluate n * fact(n - 1). Once n does reach 0, it returns the next multiplier (1) and then the first call to fact will be able to return the evaluated result. All of these is quite literally a chain of returns.","Here's a diagram of what's really happening:","Here you can see the chain of returns, and how each fact call looks. Each time there's an attempt to return, it must evaluate what the value of fact(n - 1) is before giving back a value. Which is why the second it tries to return 3 * fact(2), it evaluates fact(2), but fact(2) will have to evaluate fact(1), and fact(1) will have to evaluate fact(0). The second that chain breaks by returning 1, it goes back up each return and will \"insert\" the result of that fact call and multiply it. I tried to show this as best I could, the return statements evaluated in parentheses, the result in square brackets [X] and a display to show the chain of where it's inserted/used as the multiplier in the above return.","Another example of recursion would be a Fibonacci sequence:","Here, it will calculate n-1 + n-2 until both n s reach a value which is less than 3. Each of these fib calls chain out like fact did, each call must be evaluated before it can be returned for usage.","Again, the evaluation is in parentheses, the result is in square brackets and moves back up the chain. Reading this diagram, you go bottom-right, then follow the square brackets back up the chain, up-left."]}],[{"l":"Weak Tables","p":["Lua's way of memory management is running something called a garbage collector. Every garbage collection cycle, all objects that have no references is freed back up to use to the program. Weak tables are a way to let the garbage collector know that it can go ahead and free up the memory if there are no references to that object anymore.","The weakness of a table is set by the __mode metamethod, if the string of __mode contains k, the keys are weak. If it contains v, the values are weak. If it contains both (kv), both the keys and values are considered weak.","Example:"]}],[{"l":"Control Structures","p":["Control Structures define which way a program flows. Lua provides a simple set of generic control structures seen in most languages today:","if, then, else, elseif","while","repeat","for","break","return","Each of these control structures determines the way your code flows in your program. Each one besides return, break, and repeat are terminated by the end keyword."]},{"i":"if-then-else-elseif","l":"if, then, else, elseif","p":["An if statement tests the condition given and determines whether or not to move forward, if the condition is truthy it executes the code given in the first if block. Otherwise, if there is an elseif statement, that condition is also tested and has the exact same behavior as an if statement. If none of those conditions evaluate to true, the else block is executed. Each if statement should be accompanied by an end to terminate the control structure, you should not place them for any else or elseif s you may place. Each statement may only contain one if, any number of elseif s, one else, and finally one end.","A general if statement:","If our condition was truthy (any value that isn't false or nil), the print will be executed. Otherwise, nothing will happen.","An example using all keywords:","In this example, all conditions evaluate to false because x - y is 40, which is not less than 10 nor 20, resulting in the last print being executed, since the else keyword is a fallback in the case that no other conditions are truthy."]},{"l":"while","p":["A while loop will continuously execute its body as long as the condition provided is truthy. The condition is evaluated each time before executing the body again.","Structure of a while loop:","More information & examples are covered in the Loops page."]},{"l":"repeat","p":["A repeat loop will also continuously execute its body as long as the condition provided is truthy. The difference here is that the condition is evaluated after the body runs, not before. So any repeat loop will always execute at least once.","Structure of a repeat loop:","More information & examples are covered in the Loops page."]},{"l":"for","p":["There are two different kinds of for loops, a numeric for, or a generic for. These also execute their bodies until the loop is terminated.","A numeric for is ran for a specific amount of times, the loop variable starts at the number provided for start, and stops at the number provided for stop. The loop variable gets incremented by the step each iteration, the default being 1.","A generic for loop traverses all values returned by an iterator (a function which provides a way to traverse a container, or a specific set of values)","More information & examples are covered in the Loops page."]},{"l":"break","p":["A break will instantly halt execution and break any loop, and will not be able to return back to the loop.","More information & examples are covered in the Loops page."]},{"l":"return","p":["A return gives back any number of values from a function, it works like a break in the sense that it halts execution of the function and can't continue onward at any point.","In this single return, 3 values are returned and can be unpacked into variables, or a table if you have no idea how many values will be returned, like this:","Here, the default return value is 1, 2, 3, 4, 5, if the condition to the if statement is false, the default is used. However, if arg evaluates to true in the if statement, 1, 2, 3 will be returned and not 1, 2, 3, 4, 5, since return breaks out of the function, the rest of the code will not be executed.","Since Lua automatically assigns indexes like previously discussed, unpacking it like this creates an array the same way you do it manually, which lets you use a different way to get all returned values of a function if you don't specifically know how many or what values it's returning.","If you still use variables to unpack the return values into, they are unpacked in order, so even if you have 3 variables and 5 return values, it will use the first 3 return values to assign those variables in sequence:"]}],[{"i":"#","p":["What you'll need to know before moving on."]},{"l":"Introduction","p":["Types","Variables","Operators","Control Structures","Conditions","Loops","Functions","Scopes","File Handling (I/O)","Object-Oriented-Programming"]}],[{"l":"Loops","p":["Loops are one of the most powerful concepts in any language. They provide a way to repeat a certain process for any number of times or based off of any condition. This lets programmers simplify and condense code that could otherwise result in thousands of lines of code."]},{"l":"for loops","p":["The simplest loop is a numerical loop, described in the previous section. Here is an example of how to use one:","Here we're able to print numbers 1 through 10 by defining the start and stop as 1, and 10 respectively. The step (increments the loop variable) is defaulted to 1, which lets us move from 1 to 10 one step at a time (hence the name step).","Here's what it would look like with an explicitly defined step variable:","Here's the output:","Since the step variable is defined as 2, each iteration it increments our loop variable i by 2. Since it begins with 1, it hops to 3, 5, 7, and 9. The stopping point is 10, and since after the loop variable is incremented from 9 to 11, the loop is terminated since the loop variable is greater than or equal to its stop variable.","Now, generic for loops provide a way to iterate through a set of data. Here's an example:","This particular chunk of code will traverse through the table and multiply each value by 5, resulting in the table looking like {5, 10, 15} once the loop is finished. The iterator here is ipairs and we pass the table to it, telling ipairs to traverse that specific table for us. Each iteration, ipairs returns a key and a value (the same key and value used in the table).","ipairs will only traverse an ordered set of data, like in the above example. To traverse an unordered set of data, we use pairs.","If at least 1 key in the table is out of order, the entire data set is considered out of order, and ipairs will not work. By using pairs, Lua will traverse it in any way possible, meaning it could get to c before a and b, and any other possible combination.","It may help to think of ipairs and pairs as your hands when looking through a book. If you have a book with 3 pages inside, with a number on each one (1, 2, 3) respectively, if your hands worked like ipairs, you would look through them in order. Otherwise, if your hands worked like pairs, you would flip through each one randomly, and never the same one twice."]},{"l":"while loops","p":["While loops depend on a condition to be truthy in order to continue executing, this can be used for whenever you have no idea how many times to iterate, just until you need to satisfy a specific condition.","These can be volatile, since if there's an error in your logic and the condition you provide can never end up false, the loop will execute forever and take up a large chunk of CPU until you kill the program manually.","Here is a way to use a while loop to mimic a numeric for loop:","If i is never incremented, the condition would never be false and the loop would run forever. This code would print all numbers from 1 to 15."]},{"l":"repeat loops","p":["These and while loops are generally the same, and this is the type of loop you'll almost never see used or have a typical use of it. But, if you understand while loops you'll understand these as well.","Repeat loops check the condition to keep running after the body is executed, instead of before execution (like a while loop does). This can let you run the body at least once and it will determine if it should continue based off of a condition you provide.","An example of a numeric for in the form of a repeat loop:","Again, this code prints all numbers from 1 to 15. Since the condition is checked after the body is executed to determine whether or not to run another iteration, it needs to check for 16 since after the body executes the result will be incremented by the time it reaches the condition. So if we only want it to print up until 15, the condition needs to check if it's 1 higher since we increment it before we know it already hit 15."]},{"l":"Using the break keyword","p":["By using break, you completely terminate the loop before it reaches its natural termination. This can be useful if you're looking for a specific value in a data set, like this:","In that example, once it reaches the 2nd iteration (which will have a value of 2, since we use ipairs to iterate in the exact sequence the table is defined), it will print that the value is found and will completely terminate the loop, preventing it from iterating any further."]}],[{"l":"Operators","p":["Operators are a symbol(s) to perform a specific action. Operands are the values the operator uses in the action."]},{"l":"Relational Operators","p":["boolean (compares by value)","Comparing by reference means both operands must point to the exact same memory address, the value of its contents don't matter. Example:","function (compares by reference)","If a is anything but b, the result is true, otherwise, false.","If a is exactly equal to b, the result is true, otherwise, false.","If the value of a is greater than b, the result is true, otherwise, false.","If the value of a is greater than or equal to b, the result is true, otherwise, false.","If the value of a is less than b, the result is true, otherwise, false.","If the value of a is less than or equal to b, the result is true, otherwise, false.","number (compares by value)","Operands Types:","Operator: Equal ( a == b)","Operator: Greater Than ( a b)","Operator: Greater Than or Equal To ( a = b)","Operator: Less Than ( a b)","Operator: Less Than or Equal To ( a = b)","Operator: Not Equal ( a ~= b)","string (compares by alphabetical order)","string (compares by value)","table (compares by reference)","thread (compares by reference)","userdata (compares by reference)","When using these operators, both operands must be the of the same type."]},{"l":"Logical Operators","p":["Note: When something is defined as being \"truthy\", it means that the value is considered to be true by Lua, which is any value that isn't false or nil.","Syntax: a and b where a & b are both evaluated as expressions.","If a is truthy, b is the result of the operation, otherwise it is the result of a.","Syntax: a or b where a & b are both evaluated as expressions.","If a is truthy, result is a, otherwise b.","Syntax: not a","Inverts the truthiness of a, any expression or value that results in true, the value is flipped to false, and vice versa.","Here are some more examples pairing these operators together:","Since 1 (x) is not a greater number than 2 (y), the result of the and operator is nil because of the a operand resulting in false, the or operator comes in because the result of the and operation is the a operand to or, so the result looks like nil or 'Y is greater!'. In plain English, all that's happening here is: \"If my x variable is bigger than our y variable, give me back a string that says X is greater, otherwise, give me a string that says Y is greater.\""]},{"l":"Mathematical Operators","p":["Syntax: a + b","Syntax: a - b","Syntax: a * b","Syntax: a / b","Syntax: a ^ b","Syntax: -a"]},{"l":"Concatenation","p":["Concatenation is an operation that joins two strings together. The result is a copy of both strings joined together, since Lua cannot manipulate the contents of a string itself.","Syntax: a .. b","Examples:","You can chain these operators however many times you like in any order."]},{"l":"Length","p":["The length operator (#) is primarily used on tables, but can be effective for strings as well. For strings, it returns the number of bytes (usually each byte is a single character). For tables, it returns the length of the table as long as it has no holes and is ordered:","Depending on the version of Lua you're using, if the array or table has nil values inbetween the other values, the result of the length operator will be different. Any keys that aren't numerical are not counted towards the length.","If you have keys that aren't numbers, or have nil values/holes in your table, a table size function can be implemented by simply using the pairs iterator:"]}],[{"l":"Scopes","p":["Scopes are what define the range of functionality to a variable or function. This specifically applies in Lua to local variables & functions. When you define a variable or function with local, its scope is defined by the innermost block of code you define it in.","Example of various scopes:","Another example showing a function's scope:"]}],[{"l":"Types"},{"l":"Quick Description","p":["nil: A type to denote a value that is nothing, nonexistent, null.","string: A sequence of characters (letters, symbols, numbers).","number: Any kind of number.","boolean: Two types of values, true or false.","function: A chunk of redistributable code to be executed at a later time.","table: The only data structure in the language, holds key, value pairs.","userdata: A chunk of memory which holds C data (Lua's parent language).","thread: A reference to a coroutine."]},{"i":"more-information--examples","l":"More Information & Examples","p":["Since userdata and threads are advanced and are rarely used, they will not be covered here."]},{"l":"nil"},{"l":"string"},{"l":"Escape Sequences","p":["Escape sequences are a way to translate its sequence into a different character that may be difficult or impossible to respresent in a string. In Lua, the escape sequence is denoted by a backslash followed by a special character.","\\\": double quote","\\': single quote","\\\\: backslash","\\n: new line","These are the main escape sequences you'll ever need to use, if you wish to see the full list, check out the Auxiliary chapter of this book.","This is a string utilizing the double quote escape sequence to insert a literal double quote into the string. The reason for this is that if you do this without using an escape sequence, you will break out of the string because a string starts with the first quote and ends with the second. More about this can be read in the Operators page.","The same can be done with single quotes:","Inserting literal backslashes into a string:","And finally, newline:","Here is a string that cannot have any escape sequences in it, everything is interpreted as raw characters."]},{"l":"number","p":["The main thing that might not be obvious is the use of e, which means the following number is an exponent."]},{"l":"boolean","p":["Booleans are simple, there are only 2 possible values: true and false. Their main use is to indicate whether or not an operation or function call is successful, and used to indicate truthiness in a condition expression, which is covered in the Operators page."]},{"l":"table","p":["Tables are (in my opinion) the most fun & complex data type Lua has to offer. They hold key, value pairs of data which can let you hold any kind of data you want in any order or way you'd like. The easiest way to learn how it works, is by thinking of tables as a ton of storage lockers. With a storage locker, you need a key to access what's inside of it, the same concept applies to tables. The keys for tables can be any type of value (except nil), and the value can be any type of value. All values must be separated by a comma.","Keys are denoted by either [key] or key. If square brackets are used, the key can be of any type, but writing the key plainly is a shortcut for a key with a string type. Here's a simple example of an array of numbers:","You can see here that no keys are explicitly defined. If you don't explicitly define keys, they are automatically ordered starting from 1. Here's the exact same array but written with keys to show what it looks like:","Both are equivalent, however, the first one is much shorter and easier to look at if you understand how it works internally.","Here is an example of what a player might look like for a game:","Each key in this example is a string type, since no brackets are used. The exact same can be written with square brackets like so:","Tables can also be nested (a table inside of a table), here's an example:","Again, since there's no explicit definition of the keys, they are automatically ordered starting from 1. To access tables, you can use either the table[key] syntax, or table.key. The difference between both is the same concept as before: with square brackets the key can be of any type, with the period the key must be a string. Here's an example:"]},{"l":"function","p":["Functions are extremely powerful, they allow you to reuse code at any time of your choosing instead of having to copy/paste a set of code over and over again, which results in cleaner and more organized code.","Take this function for example, this defines a new function called average which calculates the average of the parameters passed (a & b), and uses the return keyword to give back a value which we use to show its output to the console.","You will see the word \"call\" many times throughout this book, calling means to invoke or execute a function. To call a function, use parentheses + any parameters you'd like to pass after writing the name of the function, like so: function_name(param1, param2, etc)","When passing an argument to a function, it is first evaluated before the value is inserted as the parameter. In the example above, print is called and the result of average(5, 7) is inserted as the first parameter. However, if you don't call the function, it would give an output like this:","The reason it outputs the function itself, is because it isn't called. We're simply passing the function itself to the first parameter of print instead of calling it to get a result from it.","Functions can also be a part of tables, and can be explicitly defined inside of said table within the function name using the . syntax used for tables normally:","This will be prudent in the future since Lua's standard libraries include functions inside of tables, such as table.insert, which is part of the table library.","Now to introduce variadic functions. These work the same as normal functions, except they have a special parameter (which is ...) that holds any number of values passed to it. The best example of this is the print function, it holds any number of parameters and outputs all of them in sequence to the console. The print function is basically written as this:","Don't worry if you have no clue what's going on, since this uses things we haven't gone over yet (but if you'd like to understand now, head to the Loops page and come back). The gist is that ... holds the rest of the arguments passed to the function, and it is dumped into a table so we can access them, then the rest is just outputting each argument in sequence along with a new line.","The variadic parameter doesn't have to be the only one in the parameter list, it can be used to hold any values after a specific set of arguments you'd like to take in first, like so:","Parameters a & b hold 1 & 2 respectively, while the rest of the arguments are held in ..., which can't be accessed out-of-the-box like a & b can."]}],[{"l":"Variables","p":["Variables are a way to name a piece of data for future reference and usage. They can be reused over and over again without having to be recalculated or manually typed out again.","An analogy that could provide understanding of variables is a box. Say you have a box and put an object inside of it, then mark it so you know what's inside for future reference. Variables are that box, the value of the variable is the object inside of it, and the mark on the box is the variable name. When you access a variable, you take that object out to use it however you'd like.","There are two types of variables, a local variable and a global variable. Since explaining the difference involves scopes which requires knowledge of Control Structures, the difference will be covered later on in the Scopes section.","For now, we'll be using the local keyword to define any variables. The syntax for defining a local variable is: local variable_name = value. Since Lua is a dynamically-typed language, there's no need to define the type of value you're using, just assign a value & go.","Example of a simple variable called x:","You can also reference the value of another variable (or itself) inside the assignment:","Variables really help out when you have a result of an expensive operation or calculation, since you can store the value without having to do that same operation or calculation again.","Since var is assigned to the result of the expensive function, its value can be accessed as many times as we need without having to spend another second each time we need to use that specific value.","Plenty more examples for variables using different types of values are in the next page."]}],[{"l":"Basic"},{"l":"_G","p":["Description: Global variable that holds the global environment (all global functions/variables)","Example:"]},{"l":"setfenv","p":["Description: sets the environment for a function to use, rather than _G.","Usage: setfenv(f)","Example:"]},{"l":"getfenv","p":["Description: returns the environment in use by given function or stack level, default 1.","Usage: getfenv([f])","Example:"]},{"l":"setmetatable","p":["Description: sets the metatable for given table","Usage: setmetatable(table, metatable)","Example:"]},{"l":"getmetatable","p":["Description: gets the metatable of specified table, returning the __metatable metamethod's value if applicable","Usage: getmetatable(table)","Example:"]},{"l":"rawset","p":["Description: sets a value in the table at specified index without invoking any metamethods","Usage: rawset(table, index, value)","Example:"]},{"l":"rawget","p":["Description: returns a value from a table at given index without invoking any metamethods","Usage: rawget(table, index)","Example:"]},{"l":"rawequal","p":["Description: compares two values using == without invoking any metamethod","Usage: rawequal(v1, v2)","Example:"]},{"l":"pairs","p":["Description: iterator to traverse over a table in any order possible","Usage: pairs(t)","Example:"]},{"l":"ipairs","p":["Description: iterator to traverse over a table in sequence","Usage: ipairs(t)","Example:"]},{"l":"loadstring","p":["Description: loads a Lua chunk","Usage: loadstring(string [, chunkName])","Example:"]},{"l":"loadfile","p":["Description: loads a Lua chunk from specified file, or from standard input if filename is not specified","Usage: loadfile([filename])","Example:"]},{"l":"next","p":["Description: returns the next key, value pair in table starting from specified index, otherwise index, is nil","Usage: next(table [, index])","Example:"]},{"l":"pcall","p":["Description: calls a function in a protected state, returning any errors if they happen, otherwise returns true if successful plus the returned values from f","Usage: pcall(f, ...)","Example:"]},{"l":"xpcall","p":["Description: calls a function in a protected state, using err as the error handler and returning true if no errors happen, otherwise returns false plus the result from err","Usage: xpcall(f, err)","Example:","Output:"]},{"l":"unpack","p":["Description: unpacks a table in sequence, starting from i and ending with j (1, #table respectively by default), returning all values from it","Usage: unpack(table [, i [, j]])","Example:"]},{"l":"type","p":["Description: returns the data type of given value","Usage: type(value)","Example:"]},{"l":"tonumber","p":["Description: converts value to a number if possible","Usage: tonumber(val [,base])","Example:"]},{"l":"tostring","p":["Description: converts value to a string","Usage: tostring(val)","Example:"]}],[{"l":"Coroutine"}],[{"l":"IO"}],[{"l":"Math"}],[{"i":"os-operating-system","l":"OS (Operating System)"}],[{"l":"Package"}],[{"l":"String"}],[{"l":"Table"},{"i":"tableconcat","l":"table.concat","p":["Description: concatenates all strings in the table, starting from i, ending with j (default 1, #t respectively), separating with the separator value if defined, otherwise there is no separation.","Usage: table.concat(table [, separator [, i [, j]]])","Example:"]},{"i":"tableinsert","l":"table.insert","p":["Description: inserts a value to the end of the table, or at pos","Usage: table.insert(table, [pos,] value)","Example:"]},{"i":"tablemaxn","l":"table.maxn","p":["Description: returns the highest numerical index found in the table (different from true size)","Usage: table.maxn(table)","Example:"]},{"i":"tableremove","l":"table.remove","p":["Description: removes a value from the table at the end, or at pos","Usage: table.remove(table [, pos])","Example:"]},{"i":"tablesort","l":"table.sort","p":["Description: sorts table with given comp(comparison) function, if not given, is used by default, which results in least to greatest.","Usage: table.sort(table [, comp])","Example:"]}],[{"l":"Formatting","p":["Hello"]}],[{"l":"Welcome"}]]